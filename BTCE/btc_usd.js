// Generated by CoffeeScript 1.10.0
(function() {
  var action, btc, buy, cleaner, getAccountState, getPairState, lastBuy, lastSell, name, pair, sell, serverTime, tickTime, toFixed, toFixed3, toFixed5, trade, trader, usd;

  pair = 'btc_usd';

  name = "[BTCE " + pair + "]";

  trader = require('./trader');

  tickTime = 2500;

  buy = 0;

  sell = 0;

  lastBuy = 0;

  lastSell = 0;

  usd = 0;

  btc = 0;

  serverTime = 0;

  trade = function() {
    return getAccountState(function() {
      return cleaner(function() {
        return getPairState(function() {
          return action();
        });
      });
    });
  };

  getAccountState = function(next) {
    return trader.info({
      success: function(value) {
        var data, error, funds;
        try {
          data = value["return"];
          funds = data.funds;
          usd = funds.usd;
          btc = funds.btc;
          serverTime = data.server_time;
          return next();
        } catch (error) {
          return logError(name + " Ошибка формата состояния аккаунта");
        }
      },
      failure: function() {
        return logError(name + " Ошибка получения текущей информации");
      }
    });
  };

  cleaner = function(next) {
    return trader.orders({
      pair: pair,
      success: function(value) {
        var buffer, created, error, id, order, ref;
        if (!value) {
          next();
        }
        try {
          ref = value["return"];
          for (id in ref) {
            order = ref[id];
            created = order.timestamp_created;
            buffer = serverTime - (tickTime * 30 / 1000);
            if (created < buffer) {
              trader.cancel({
                id: id
              });
            }
          }
        } catch (error) {
          logError(name + " Ошибка формата списка ордеров");
        }
        return next();
      },
      failure: function() {
        return logError(name + " Проблемы с получением списка ордеров");
      }
    });
  };

  getPairState = function(next) {
    return trader.ticker({
      pair: pair,
      success: function(value) {
        var error, ticker;
        try {
          ticker = value.ticker;
          lastBuy = buy;
          lastSell = sell;
          buy = ticker.buy;
          sell = ticker.sell;
          return next();
        } catch (error) {
          return logError(name + " Ошибка формата тикера");
        }
      }
    });
  };

  action = function() {
    var buyAmount, buyRate, minBtc;
    if (!lastSell) {
      return;
    }
    minBtc = 0.01;
    if (btc && btc > minBtc) {
      trader.sell({
        pair: pair,
        rate: toFixed3(buy - (buy - sell) / 2.5),
        amount: btc
      });
    }
    buyRate = toFixed3((buy + sell) / 2);
    buyAmount = toFixed5(usd / sell - 0.001);
    if (buyAmount > minBtc && usd && buy > lastBuy) {
      return trader.buy({
        pair: pair,
        rate: buyRate,
        amount: buyAmount
      });
    }
  };

  toFixed3 = function(value) {
    return toFixed(value, 3);
  };

  toFixed5 = function(value) {
    return toFixed(value, 5);
  };

  toFixed = function(value, dot) {
    return +(value.toFixed(dot));
  };

  trade();

  setInterval(trade, tickTime);

}).call(this);

//# sourceMappingURL=btc_usd.js.map
